# Замечания по домашкам и долг

## Не делать `forEach` просто так
Плохая идея: `(0..10).forEach { ... }`, лучше обычный `for`
Пограничный случай: `(0..10).map { ... }.forEach { ...}`
Зачем на самом деле нужен `forEach`: `?.forEach` (см. слайд)

## Зачем нужен `let`
Если `a.getNullableValue()` возвращает nullable, а `transform` принимает не-nullable,
то можно обработать так:
`a.getNullableValue()?.let { transform(it) } ?: return null`

## Синглтоны и `object`
Очень часто я видел, что их используют для ограничения
видимости области декларация. Это неправильно, для этого
стоит использовать пакеты или отдельные файлы.
`object`'ы --- это именно для создания одного конкретного объекта,
реализующего конкретный интерфейс (самая частая причина).
Всё остальное --- на грани.

## Стандартная библиотека и прочие фишки
Это были последние слайды лекции.
Очень, очень рекомендуется поизучать функции из стандартной библиотеки.
Ну и вообще на слайдах там много чего интересного.

# Builder'ы
## Функциональный тип с receiver'ом
Это как бы такая extension-функция:
```
val block: String.() -> Int
block("str")
"str".block()
```

Но гораздо важнее то, как ведёт себя сама лямбда, которую мы передали.
Правила такие же, как для extension-функций:
```
builder {
  this.length  // Можно обращаться к публичными полям (только к ним)
  this@builder.length  // Можно через собачку
  length  // Можно неявный this
}
```

В такой `builder` можно передавать любую функцию с подходящей сигнатурой
(первый параметр принимает `String`???)

## Функция `with`
Позволяет вводить неявный `this` в контекст, реализована как раз через функциональный тип с receiver'ом:
```
with ("") l1@{ // Метка относится к блоку
  length
  this.length
  this@l1.length
  this@with.length  // Если бы метки не было, вызывали бы по имени функции
  with (listOf("foo)) {  // Метка опциональна
    length  // Длина списка
	this.length  // Обращаемся к самому вложенному with
    this@l2.length // Можно явно по метке
  }
}
```

На самом деле этот неявный `this` вводит, конечно, функциональный тип с receiver'ом.

Пример применения по делу:
```
val descr = with(database.findPerson(123)) { "$firstName $secondName $email" }
```
Но каждый раз, когда вы добавляете Implicit receiver, вы усложняете чтение кода.

## Функция `run`
Просто выполняет свой параметр типа `() -> R`.
Полезно, когда мы хотим выйти из куска кода заранее, например:
```
val x: Int? = run l@{
  val res = foo() ?: return@l null
  return bar(res)
```
Опять же, это усложняет чтение.

## Функция `also`
Это extension-функция, которая принимает блок с аргументом `T` и выполняет его на `this`,
а возвращает `this`.
Пример использования: есть кусок куда, который конструирует объект, который надо вернуть,
но перед этим что-то сделать. Например, в кэш положить:
```
return Obj(key).also(::putToCache)
```

## Функция `apply`
Это extension-функция, которая принимает блок с receiver'ом и выполняет его на `this`,
а возвращает `this` (почти как `also`).
Пример использования: типа-builder: создали мутабельный объект, поменяли:
```
return MutablePerson().apply {
  name = "foo"
  email = "bar"
  for (...) {
    addProperty(...)
  }
}.toImmutablePerson()
```

Можно ещё сделать immutable:
```
val result = StringBuilder().apply {
    for (line in lines) { append(line) }
}.toString()
```
Конкретно так делать, конечно, не надо, потому что есть стандартная функция `stringBuild`.

## Что-то потерял тут

## DSL Builders
Можно сделать HTML Builder, который выглядит так:
```
createHTML().html {
  // Есть неявный this для корня HTML
  head {
    // Есть новый неявный this для <head>
    title { +"XML encoding with Kotlin }
  }
  body {
    // Есть новый неявный this для <body>
    h1 { +"XML encoding with Kotlin }
	for (person in rows) {
	  div { +person.toString() }
	}
  }
}
```

Плюсик - это просто унарный плюс.

### Как бороться с несколькими receiver'ами
Неудачный код, но компилируется: `html { head { head } }`.
Можно добавить аннотацию `HtmlMarker`, помеченную метааннотацией`DslMarker`.

Теперь если мы встретим две лямбды, которые относятся "к одному языку"
(т.е. их receiver или его родитель помечен аннотацией `HtmlMarker`),
то неявно можно вызывать только методы самой внутренней из них.
```
html {
  head {
    head { } // нельзя
	this@html.head { } // можно
  }
}
```
При этом для receiver'ов остальных языков всё ещё можно неявно вызывать.

Вообще разработчики Android любят Kotlin за то, что там есть классная
либа для создания GUI в виде таких DSL.
