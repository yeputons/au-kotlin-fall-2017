Взаимодействие с Java

# Предыстория
Одна из идей при создании Kotlin была в том, что он должен
обеспечивать удобное взаимодействие с Java.
В частности, в большом Java-проекте должно быть просто начать
писать на Kotlin.
Это довольно сложная штука для дизайнеров языке: между языками
много общего, но каждое различие порождает много проблем, было
сложно искать компромиссы.

Взаимодействие (interoparability/interop) бывает двух видов:

* Вызов кода на Kotlin из Java (нужно только если мы расширяем проект)
* Вызов кода на Java из Kotlin (нужно почти всегда, когда мы используем Java-библиотеки)

В отличие от Scala, Kotlin интегрируется в существующие системы сборки
для Java (Maven, Gradle, Ant, IDEA).

Почти вся презентация неактуальна, если у нас проект целиком на Kotlin.

# Как работает сборка
Компилятор Java ничего не знает про Kotlin, однако из
исходников на Java может вызываться Kotlin. Поэтому работает так:
1. Сначала kotlinc прочитает всё
2. Поймёт интерфейсы Java-классов
3. Скомпилирует `.kt` в `.class`
4. Запустит javac, который уже будет читать сигнатуры Kotlin-методов из `.class` и компилировать `.java` в `.class`

# Как видны конструкции Kotlin в Java
## Простые поля
`class A(var name: String)` видно, как `A::getName()` и `A::setName(s)` в Java.
Соответственно, делать методы с названиями `getName`/`setName` в Kotlin нельзя.
Можно изменить (см. ниже).

## Top-level/package функции/свойства
Эти невозможные в Java конструкции превращается в статические методы
синтетического класса с названием `ExampleKt` (если был файл `example.kt`).
Вообще исходно думали называть класс `Example`, но это неудобно: часто
оказывалось, что в файле с именем `example.kt` объявлен класс `Example`.

Можно указать аннотацию уровня файла (в Java такого не бывает):
`@file:JvmName("Utils")` - это изменит имя с `ExampleKt` на `Utiles`.

Ещё можно указать аннотацию `@file:JvmMultifileClass`, чтобы можно
было указать одинаковыё `@file:JvmName` в разных файлах, чтобы
получился один класс с кучей статических top-level функций.
Если её не добавить хотя бы в один файл эту аннотацию, то не скомпилируется.

## Object'ы
`class MyClass { companion object { fun bar() {} }}`
Обычные `object` и `companion object`'ы компилируются в классы, экземпляр
которого доступен, как статическое поле.
Для компаньонов: `MyClass.Companion.bar()`

`object Singleton { fun bar() }
А для `object`'ов надо вызывать `Singleton.INSTANCE.bar()`.

Но можно аннотировать метод `@JvmStatic`, тогда метод честно скомпилируется
в Java как статический. Например, если у нас есть фабричный статический метод:
```
class MyClass { companion object { @JvmStatic fun bar() {} } }
// MyClass.bar()
```

Зачем так сделано? В Kotlin объекты могут наследоваться от классов/интерфейсов.
Можно, например, делать `override` метода или делать upcast в интерфейс.
Со `static` в Java так нельзя. Поэтому если уж нужен именно статический метод,
то надо писать аннотацию и на него появятся какие-то ограничения.

## Поля
Если аннотировать поле `@JvmField val myField = 1`, то оно в Java
будет видно публичным полем. Например, это полезно, если у нас
есть внешний dependency injector, который пишет в публичные поля.
Так можно только если отсутствуют геттер и сеттер.
Если `val` - у нас будет `final`-поле, если `var` - то будет обычное поле(?).

Если указать `@JvmField` для поля в объекте (неважно, компаньоне или нет):
`class Key { companion object { @JvmField val foo = 1 } }`
то оно будет доступно как `Key.foo`.
А без него надо было бы писать `Key.Companion.getFoo()`

## const
К некоторым `val`'ам можно дописать слово "const" (к тем, которые можно использовать
в аннотациях - примитивные типы, массивы; означает "compile-time constant").
Они будут компилироваться в `static final`-поля, доступные через `MyClass.myField`.
Они будут инлайнится при использовании. В Котлине - точно, в Java - наверняка.

## Type erasure
Вот так писать нельзя из-за type erasure в конкретно JVM (но Kotlin'у-то пофиг):
```
fun bar(x: List<String>)
fun foo(x: List<Int>)
fun List<String>.foo()
fun List<Int>.foo()
```
Можно задать имя метода при помощи `@JvmName`:
```
fun List<String>.foo()
@JvmName("fooListInt") fun List<Int>.foo()
```
Тогда скомпилируется в JVM. Если компилировать в другую платформу, то
вроде как можно даже не писать, но я не уверен.

## Default arguments
`fun foo(x: Int = 1, y: String = "") {}`
компилируется в два метода:
```
void foo(int x, String y) {}
void foo$default(int x, String y, int nonDefaultsMask) {...}
```
Второй метод вызывается с аргументами, а в маске должны передаваться биты
с номерами параметров, которые мы явно передали (если больше 32 аргументов - будет несколько масок).
Он также отмечен флагом syntetic и из-за этого `foo$default` обычно из Java вызывать нельзя.
Отдельный метод нужен, потому что аргументы по умолчанию могут как-то хитро вычисляться.

Если у нас все параметры по умолчанию идут в конце, то можно указать `@JvmOverloads`,
тогда сгенерируются ещё и перегрузки для всех валидных префиксов
```
class Foo @JvmOverloads constructor(x: Int, y: Double = 0) {
  @JvmOverloads fun f(a: String, b: Int = 0) {}
}
```
Будет сгенерировано:
```
Foo(int, double);
Foo(int);
Foo.f(String, int);
Foo.f(String);
``

## Checked exception
В Kotlin checked exception отсутствуют и он ничего не проверяет.
Но если нам надо указать, что кидает метод - то мы можем указать:
`@Throws(IOException::class, FooException::class) fun foo() { throw IOException() }`
Например, чтобы правильно реализовать какой-нибудь Java-интерфейс.

## Вариантность параметров генерика (`in`/`out`)
```
class Box<out T>(val value: T)
interface Base
class Derived : Base
fun boxDerived(value: Derived): Box<Derived> = Box(value)
fun unboxBase(box : Box<Base>): Base = box.value
```
В Java это раньше компилировалось так:
```
Box<? extends Derived> boxDerived(Derived value) { ... }
Base unboxBase(Box<? extends Base> box) { ... }  // Сюда можно передать Box<Derived>
```
Однако так оказалось неудобно: на Java обычно не приятно писать wildcard'ы вообще,
а тут мы вызвали `boxDerived`, появился тип с wildcard, и он полез дальше.
Поэтому было принято компромиссное решение: при компиляции в return типах wildcard'ы
не пишутся, а в параметрах - пишутся:
```
Box<Derived> boxDerived(Derived value) { ... }
Base unboxBase(Box<? extends Base> box) { ... }  // Всё ещё можно передать Box<Derived>
Base unboxString(Box<String> box) { ... }  // эвристика: string является final, поэтому wildcard не нужен
```

Но это можно контролировать:
```
// Вернуть старое поведение, форсировать wildcard
fun boxDerived(value: Derived): Box<@JvmWildcard Derived>
Box<? extends Derived> boxDerived(Derived value) { ... }
// Не генерировать wildcard (например, если мы реализуем какой-то интерфейс)
fun unboxBse(box: Box<@JvmSuppressWildcards Base>): Base
Base unboxBase(Box<Base> box)
```

# Как видны конструкции Java из Kotlin
## Nullability
Основная проблема - nullability.
Fun fact: никто этого с ходу не назвал, это хорошо, этого и добивались дизайнеры языка :)

Исходно считали, что любое Java API принимает nullable аргументы
и возвращает nullable значения:
Но это, как оказалось, неудобно: `System.out?.println()`, нельзя сказать,
что поле `System.out` никогда не равно null.
Так что решение такое: создали новый класс типов - "платформенные типы" (T!),
их никак нельзя получить напрямую в Kotlin (кроме случая `val x = foo()`, где `foo() : T!`).
Мы не знаем их nullability, но есть правила:
1. T? является подтипом T!.
2. T! является подтипом T.
Из-за этого нам приходится ломать транзитивность, иначе
T? <: T! <: T <: T?, т.е. все эти типы равны.
Очень. Жаль. На самом деле вроде даже пофиг.
Это называется "постепенная типизация" или как-то так.

"Платформенный тип" в результаты позволяет трактовать себя и как nullable, и как non-nullable:
```
System.out?.println()  // ok
System.out.println()  // ok
```

Kotlin всегда проверяет на null в момент получения значения из Java, то есть NPE внутри кода
на Kotlin мы внезапно не получим.

Исключение: если у нас есть код на Java, аннотированный `@NotNull`/`@Nullable` из
какой-то известной Котлину библиотеки, то он выдаст правильный тип (`T` или `T?` вместо `T!`).

## Коллекции и массив
Есть аналогичная проблема с мутабельностью коллекций: в Java у нас интерфейс один,
а в Kotlin есть есть мутабельные и иммутабельные.
Решается так же, как nullability - платформенные типы.
Пока мы их не записали в переменную с явно указаннымм типом или не передали в
метод Kotlin, то они ведут себя одновременно и как мутабельные, и как иммутабельные,
отображаются как `(Mutable)Iterator<T>!` или `(Mutable)List<T>!`.

С массивами я прослушал, но, судя по сайту Kotlin, проблема в том,
что в Kotlin они инвариантные, а в Java - ковариантные.
Поэтому снова платформенный тип, который отображается как `Array<(out) T>!`.

Про raw-типы мы вообще ничего говорить не будем.
Их можно использовать из Kotlin, но это неудобно.

## Java 8: single abstract method interface
В Java 8 для реализации SAM-интерфейсов можно использовать лямбды.
В Kotlin по умолчанию лямбды можно использовать только для т.н. "функциональных типов".
Но придумали расширения:

### SAM-конструкторы
Если у нас есть SAM-интерфейс, то можно написать вот так:
`Runnable { println("hello world") }`
Он в каком-то смысле "добавляет конструктор" для интерфейсу.

### SAM-адаптеры
Если есть метод, который принимает SAM-интерфейс, то можно туда передавать
Kotlin-лямбду, она магическим образом сконвертируется, куда надо.

## Свойства
Методы с названием `getFooBar` можно вызывать и как метод, так
и как read-only property `fooBar`.
Если есть и геттер, и сеттер (причём с одинаковым типом), то тоже
сгенерируется свойство. Если типы разные, то свойство вообще не сгенерируется.
