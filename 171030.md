# Анонимные функции

Важная часть языка.
На слайде видно несколько вариантов записи одного и того же выражения.
Тут мы сначала задаём функцию высшего порядка, которая принимает block и вызывает block с параметром 123.
А потом вызываем её, передавая анонимные функции.

## Способы
1. Самый многословный способ записи анонимной функции.
   Как будто бы обычную функцию пишем, но только без имени.
   Обычно не используется, только если нам надо явно указать
   тип "receiver'а". Об том, что такое "функциональыный тип
   с receiver'ом", мы ещё не говорили, будет позже.
2. Вариант покороче.
   Всё ещё указываем тип явно, всё ещё полноценный блок кода,
   можно много команд,
   последняя команда должна вычисляться в возвращаемое значение.
3. Если тип параметра очевиден для компилятора и человека, можно не указывать тип.
4. Если у лямбды ровно один параметр, то он будет автоматически создан с именем `it`.
   Эта штука не работает, если у нас ноль параметров или больше одного.
   Эта штука часто используется, но с ней стоит быть осторожным:
   если вы попробуете написать `it.map { it + 1 }`, это будет невозможно читать.
5. Если последний параметр функции имеет тип "функция", то его можно указать вне скобок:
   `foo(...) { ... }` (как в Scala) или вообще опустить скобки, если это единственный параметр.
   Можно писать этакие DSL: функции, которые похожие на операторы.
   Например, функция `repeat(count) { ... }`.
6. Можно писать ровно как в Java 8.

# Extension
## Extension functions
Этакая дополнительная возможность расширения существующих классов.
(на самом деле не классов, а произвольных типов, в том числе Nullable
и с произвольными параметрами, вроде `filter` или `Any?.toString`).
Или можно рассматривать их как упрощённые implicit functions из Scala.
Чтобы использовать какую-то extension function, надо заимпортить эту функцию (либо по имени, либо пакетом).

В целом такие extension functions обычно объявляются свободными.
Но можно объявить и в классе.
Тогда у неё получается два `this` --- два receiver'а
(это всё ещё не те самые "функциональные типы с receiver'ом").
По умолчанию `this` будет идти к ближайшему receiver'у (т.е. к `String`),
а чтобы обратиться к другому, надо написать `this@A` (примерно как в Java пишем `A.this`).
Т.е. `this.length` будет эквивалентно `this@spaceToCamelCase.length`.
Почему там не `this@String` --- ну, какое-то дизайн-решение.

## Extension property
Можно добавлять геттеры/сеттер в существующие классы.
Но вот писать `val String.abc = 1` без геттера нельзя, потому что для этого
требуется добавить поле во все экземпляры класса (backing field).

## Сложные примеры
Можно добавлять типовые параметры.
Например, есть расширение `filter`. Тут писать `T` обязательно, иначе бы пришлось
определять `Iterable<Any>.filter`, но тогда бы предикат тоже принимал `Any`, что неудобно.
Разумеется, типовые параметры вполне себе автоматически выводятся.

Строки 2-3 на слайде показывают, как можно определить и использовать `let`.
Тут получается, что receiver'ом для `let` у нас является типовой параметр.
Так тоже можно.
Иногда, конечно, удобнее просто создать переменную, записать в неё receiver `let`, а потом использовать.
Но в примере `let` получается этаким `Maybe.map` для nullable-типов. Меньше кода.

## Как происходит выбор функции
Пусть мы сделали extension function `String.length` с таким же именем и сигнатурой, как member.
Внезапно, в таких случаях выбирается member.
Так что если хотим вызвать такой extension, то надо либо через reflection, либо через import с alias.

Единственное исключение --- метод `forEach` для коллекций.
Потому что Котлин разрабатывался до появления Java 8, в которой появился свой собственный `forEach`.
Так что конкретно для `forEach` из стандартной библиотеки Котлина он выигрывает у member'а.

## Static/virtual dispatching 
Никакой виртуальности у extension методов нет.
Если есть базовый класс и наследник, и для каждого есть extension метод,
то вызывается соответствующий типу выражения, а не объекта.

## Перегрузка операторов
Оператор - это синтаксический сахар вокруг вызова метода на объекте
со специальным названием: `a.plus(b)`, `a.unaryMinus()`.
Но у таких методов надо обязательно писать слово `operator` ради совместимости:
если потом добавят новый оператор с новым названием, то у нас старые методы не станут внезапно операторами.
Ассоциативность зафиксирована парсером языка.

Ещё из интересных операторов есть `get`/`set` для квадратных скобочек.

Ещё часто используется конвенция для парсинга конструкции `val (x, y) = a`:
мы просто вызываем `a.component1()` и `a.component2()`.
Особенность: если у нас три компонента, то вызовется всё равно ровно два.

Ещё можно перегружать "круглые скобки": можно написать метод `invoke`.
Разумеется, тут возникают проблемы вроде "а что если у нас есть и переменная
`a` с `invoke` и функция с именем `a`", но мы не будем в них вникать.

TODO: nullable receiver

## Infix functions
Обязаны быть либо extension'ами, либо членами класса.
Если написали `infix`, то вызов `1 to ""` конвертируется в `1.to("")`.

# Delegated properties
В примере на слайде у нас есть конструкция `by lazy { ... }` с такой семантикой:
при первом обращении вычисляется значение, запоминается, и потом возвращается
(тут мы про многопоточность не говорим, если интересно - читаем стандартную библиотеку).

По сути это просто такой синтаксический сахар для записи геттеров/сеттеров
с определённой семантикой: геттер есть вызов `getValue` на делегате,
а сеттер есть вызов `setValue` на делегате.

С версии 1.1 можно делать Local Delegated Properties, как мы увидели на паре.
То есть необязательно свойства, можем так делать на любом `val` (тогда первым параметром
вместо объекта `getValue`/`setValue` получат `null`).

# Inline functions
Это обычные функции, у которых есть модификатор `inline`.
Есть два применения.

## Первое базовое применение
Оптимизация кода.
Модификатор гарантирует, что любой вызов такой фукции будет встроен
в место вызова (если это вызов из Kotlin, конечно).
Разумеется, никакой виртуальности.
Бонус: у `inline` функции все параметры тоже становятся `inline`
(но можно написать `noinline` перед параметрами, если зачем-то хочется).
Полезно, например, в функции `filter`: тогда у нас инлайнится и цикл, и предикат.
Редко когда нужно делать inline-метод класса.
Обычно это всё-таки используется как некая замена макросам.

### Использование `return`
Почему-то не было отдельным пунктом.

Если у нас есть `forEach`, он `inline`, то мы можем внутри лямбды
писать `return` и он выйдет из глобальной функции, а не из самой лямбды.
А вот если напишем `return@filter`, то это будет просто выход из лямбды, как будто бы `continue`.
Работает только если мы пишем inline-лямбду, потому что тогда это действительно `return`.
В не-inline не работает, в Scala работает, так как там кидают исключение.

## Более гибкие возможности работы с типовыми параметрами
В Java есть проблема: если есть типовой параметр `T`, то мы с ним ничего не сделаем.
Например, не проверим, что какой-то объект имеет тип `T` (type erasure).

Если указываем у параметра слово `reified`, то мы теперь можем использовать его как обычный
класс, например, проверять, что у нас есть экземпляр такого класса.
Работает ровно потому что inline.

### Сочетание всего подряд
Когда-то на Java мы делали задание на dependency injection.
Например, могли сделать один `Container` со всеми созданными классами и
методом `getInstance`, который возвращает созданный класс по типу.
В Kotlin можно сделать удобнее: вместо `c.getInstance(MyComp::class)` можно
написать `val myComp: MyComponent by c`, а в `Container` просто добавляем
inline operator extension function с reified-параметром (чтобы знать, какого типа
искать объект).
Конечно, в данном примере мы можем вместо `T::class` написать что-то вроде
`kProperty.class` (но не уверен).

# Соглашения написания кода на Котлине
Это от нас будут требовать в домашках.
На слайдах есть примеры "как надо".
Обращайте внимание на Inspections от IDEA: преподаватели на них смотреть будут активно и внимательно.

# ДЗ
Задание на две недели на полный балл, разделения soft/hard deadline нет.
