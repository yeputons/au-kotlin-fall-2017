# Sequence
Начнём с сущности стандартной библиотеки, которую мы раньше не трогали.
`Sequence`. Это такой аналог stream'ов, которые появились в Java 8.
Интерфейс полностью идентичен `Iterable`, но у него другая семантика:

* Он может быть бесконечным
* Его элементы могут быть вычислены лениво

Например, `sequence` можно создать по индукции функцией `generateSequence(start) { **step** }`
Можно при помощи `sequenceOf(1, 2, 3)`.

С `Sequence` можно совершать такие же операции, как со Stream'ами в Java.

А ещё можно создать при помощи `buildSequence` и `yield` (как в питоне):

```
var terms = Pair(0, 1)
while (true) {
  yield(terms.first)
  terms = Pair(terms.second, terms.first + terms.second)
}
println(fibonacci().take(10).toList())
```

Что происходит: запускается выполнение лямбды, когда она вызывает `yield`,
то в итератор выдаётся соответстующее значение и исполнение лямбды замораживается.

# Suspend-функции
Инструмент для создания корутин. На самом деле это функции,
которую будут переписаны в continuation-passing style (см. ниже).
Определяются с помощью ключевого слова suspend (это ещё один модификатор).
Но можно вызывать только из других suspend-функций, как пользоваться - чуть позже.

https://kotlinlang.org/docs/reference/coroutines.html
https://github.com/Kotlin/kotlin-coroutines/blob/master/kotlin-coroutines-informal.md

## Во что компилируются
Continuation-passing style.
Есть интерфейс `Continuation(in T)` с функцией `resume(value: T)`.
Пусть есть функция `suspend fun foo(): String = "OK"` и `bar() = println(foo())`.
Скомпилируется в

```
fun foo(c : Continuation<String>): Unit {
  c.resume("OK")
}
fun bar(c : Continuation<Unit>): Unit {
  foo(object : Continuation<String> {
    override fun resume(value: String) {
	  println(value)
	}
  });
}
```

Параметр `c` обозначает "что сделать после окончания вычисления".

## `suspendCoroutine`
Вообще Continuation так просто нам не виден (он возникает в процессе компиляции),
но есть intristic-функция `suspendCoroutine` (т.е. которую пишет компилятор,
мы её на Kotlin не выразим), которая позволит нам получить к нему доступ
(примерно как `call/cc` в Scheme, судя по http://lisperator.net/pltut/cps-evaluator/continuations).
Например, можем написать `foo` вот так:

```
suspend fun foo(): String =
  suspendCoroutine { c ->
    c.resume("OK")
  }
```

Зачем это надо: например, если у нас уже есть какой-то асинхронный фреймворк
(вроде java nio или какой-то штуки, которая возвращает `Future`), то можно сделать так:

```
suspend fun waitForTask(task: Future<String>): String =
  suspendCoroutine { c ->
    task.whenComplete {
	  result, throwable -> c.resume(result)
	}
  }
```

Собственно, это пока единственная разумная ситуация, в которой у нас корутина "заморозится".

## `startCoroutine`
Называется "вызови такую suspend-функцию с таким continuation".
Сама `startCoroutine`, таким образом, работает до первого
нетривиального вызова `suspendContinuation` функции внутри своего параметра.
То есть `{ while (true); }.startCoroutine(...)` повиснет нафиг.

## `createCoroutine`
Просто создаёт нам `Continuation<Unit>`, соответствующей нашей suspend-функции.
Дальше мы на нём можем вызвать `resume(Unit)`. `startCoroutine` ровно этим и занимается.
На слайдах была бага - результат `createCoroutine` игнорился, так быть, конечно,
не должно, его надо передать в `IteratorImpl`.

## Детали
Для оптимизации каждая suspend-функция компилируется в некоторый
конечный автомат с переменными, который хранит текущее состояние этой функции.
Говорят, там создаётся наследник класса `Continuation`.
А по `resume` suspend-функция продолжает выполняться: меняем своё состояние,
вызываем ближайшую suspend-функцию.

Бывает оптимизация: корутины на самом деле не `foo(c: Continuation<String>): Unit`,
а `foo(c: Continuation<String>): Any?`, оно может либо вернуть значение сразу
(без всяких хитрых continuation), либо вернуть специальное магическое значение 
`COROUTINE_SUSPENDED`, что означает, что будет вызван continuation.
Например, `suspendCoroutine` практически всегда возвращает `COROUTINE_SUSPENDED`.

А ещё любой `Continuation` хранит внутри себя некий `CoroutineContext`,
это типа мапа переменных. Можно туда свои докидывать, чтобы был дополнительный
контекст у корутины.

Ещё бывают `ContinuationInterceptor`. Они нужны, чтобы можно было сказать
"код этой корутины должен исполняться только так" (например, только в UI thread).
Работает так: на каждом continuation `foo`, который надо зарезьюмить сейчас,
сначала выполняется `ContinuationInterceptor.interceptContinuation(foo)` и резьюмится
результат "перехвата". См. пример со SwingInterceptor, который гарантирует, что
корутина всегда живёт в UI thread для Swing.
